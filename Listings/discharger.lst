C51 COMPILER V9.60.0.0   DISCHARGER                                                        08/06/2022 14:34:50 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DISCHARGER
OBJECT MODULE PLACED IN .\Objects\discharger.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\discharger.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Inc;.\SmallRTOS
                    -\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\discharger.lst) OBJECT(.\Objects\discharger.obj)

line level    source

   1          #include "discharger.h"
   2          #include "eeprom.h"
   3          
   4          Discharger_TypeDef discharger = {0};
   5          
   6          /*获取交流电压*/
   7          #define __Get_VC_Voltage(uart, addr) \
   8              ((float)uart->Rx.pbuf[addr] * 25.6F + (float)uart->Rx.pbuf[addr + 1U] * 0.1F)
   9          /*获取直流电压*/
  10          #define __Get_DC_Voltage(uart, addr)                                                                \
  11              ((float)uart->Rx.pbuf[addr] * 32.0F + (float)((uart->Rx.pbuf[addr + 1U] & 0xF0) >> 4U) * 2.0F + \
  12               (float)(uart->Rx.pbuf[addr + 1U] & 0x0F) * 0.1F)
  13          /*获取放电功率*/
  14          #define __Get_DisPower(uart, addr) \
  15              ((float)uart->Rx.pbuf[addr] * 25.6F + (float)uart->Rx.pbuf[addr + 1U] / 10.0F)
  16          /*组合2字节数据*/
  17          #define __Get_Data(uart, addr) \
  18              ((uint16_t)(uart->Rx.pbuf[addr] << 8U | uart->Rx.pbuf[addr + 1U]))
  19          /*获取系统温度*/
  20          #define __Get_SystemTemparture(x) \
  21              (x > 320U ? (-35.02 * log(x) + 246.42F) : (-0.0916F * x + 72.756F))
  22          
  23          /**
  24           * @brief       放电数据处理
  25           * @details
  26           * @param       None
  27           * @retval      None
  28           */
  29          void Discharger_Handle(Discharger_TypeDef *pd, Uart_HandleTypeDef *puart)
  30          {
  31   1      #define DATA_START_ADDR 287U
  32   1          if (pd && puart)
  33   1          {
  34   2                      /*解决部分变量未清零*/
  35   2                      memset(&pd->Current, 0x00, sizeof(pd->Current));
  36   2              pd->Current.V_Discharger = __Get_VC_Voltage(puart, 280U);
  37   2              pd->Current.P_Discharger = __Get_DisPower(puart, 282U);
  38   2              pd->Current.V_Battery = __Get_DC_Voltage(puart, 284U);
  39   2              pd->Current.S_Temperature = __Get_SystemTemparture(__Get_Data(puart, 292U));
  40   2              if (pd->Current.V_Battery)
  41   2              {
  42   3                  pd->Current.I_Discharger = (pd->Current.P_Discharger / pd->Current.V_Battery); //       *sqrt(
             -3.0F);
  43   3              }
  44   2              // pd->Current.T_Discharger += 1;
  45   2              /*识别工作状态*/
  46   2              if (pd->Current.V_Discharger < 200.0F)
  47   2              {
  48   3                  __SET_FLAG(pd->Current.M_State, Error), __RESET_FLAG(pd->Current.M_State, Work),
  49   3                      __RESET_FLAG(pd->Current.M_State, Standy), __RESET_FLAG(pd->Current.M_State, End);
  50   3                  pd->Current.Animation = false;
  51   3              }
  52   2              else
  53   2              {
C51 COMPILER V9.60.0.0   DISCHARGER                                                        08/06/2022 14:34:50 PAGE 2   

  54   3                  if (pd->Current.P_Discharger > 15.0F)
  55   3                  {
  56   4                      __RESET_FLAG(pd->Current.M_State, Error), __SET_FLAG(pd->Current.M_State, Work),
  57   4                          __RESET_FLAG(pd->Current.M_State, Standy), __RESET_FLAG(pd->Current.M_State, End);
  58   4                      __SET_FLAG(pd->Current.M_State, Start);
  59   4                      pd->Current.Animation = true;
  60   4                  }
  61   3                  else
  62   3                  {
  63   4                      pd->Current.Animation = false;
  64   4                      __SET_FLAG(pd->Current.M_State, Standy);
  65   4                      __RESET_FLAG(pd->Current.M_State, Error), __RESET_FLAG(pd->Current.M_State, Work);
  66   4                      __GET_FLAG(pd->Current.M_State, Start) ? __SET_FLAG(pd->Current.M_State, End)
  67   4                                                             : __RESET_FLAG(pd->Current.M_State, End);
  68   4                      /*放电对象被拔下，结束本轮放电*/
  69   4                      if (pd->Current.V_Battery < 10.0F)
  70   4                      {
  71   5                          __RESET_FLAG(pd->Current.M_State, Start);
  72   5                      }
  73   4                  }
  74   3              }
  75   2          }
  76   1          /*可以增加波形显示*/
  77   1      }
  78          
  79          #define __Set_BufData(buf, site, value) \
  80              (buf[site] = value)
  81          /**
  82           * @brief       根据放电参数设置数据帧
  83           * @details
  84           * @param       None
  85           * @retval      None
  86           */
  87          void Set_DischargerParam(Discharger_TypeDef *pd, uint8_t *pbuf)
  88          {
  89   1          if (pd && pbuf)
  90   1          {
  91   2              /*设置从站ID*/
  92   2              if (!(pd->Storage.Slave_Id > 0U) || !(pd->Storage.Slave_Id < 33U))
  93   2              {
  94   3                  pd->Storage.Slave_Id = 1U;
  95   3              }
  96   2              __Set_BufData(pbuf, 38, pd->Storage.Slave_Id);
  97   2              /*设置内部限制*/
  98   2              __GET_FLAG(pd->Storage.flag, Internal_Limit) ? __Set_BufData(pbuf, 4, 2U),
  99   2                  __Set_BufData(pbuf, 5, 0U)               : (__Set_BufData(pbuf, 4, 0U), __Set_BufData(pbuf, 5,
             - 1U));
 100   2              /*设置电流极限*/
 101   2              __GET_FLAG(pd->Storage.flag, I_Limit_Enable) ? __Set_BufData(pbuf, 31, 1U) : __Set_BufData(pbuf, 3
             -1, 0U);
 102   2              /*设置放电电流*/
 103   2              if (!(pd->Storage.I_Limit > 0U) || !(pd->Storage.I_Limit < 36U))
 104   2              {
 105   3                  pd->Storage.I_Limit = 1U;
 106   3              }
 107   2              __Set_BufData(pbuf, 33, pd->Storage.I_Limit);
 108   2              /*检查功率和电流模式二选一*/
 109   2              if (__GET_FLAG(pd->Storage.flag, I_Limit_Enable) && __GET_FLAG(pd->Storage.flag, P_Limit_Enable))
 110   2              {
 111   3                  __RESET_FLAG(pd->Storage.flag, P_Limit_Enable);
 112   3              }
 113   2              /*设置功率极限*/
C51 COMPILER V9.60.0.0   DISCHARGER                                                        08/06/2022 14:34:50 PAGE 3   

 114   2              __GET_FLAG(pd->Storage.flag, P_Limit_Enable) ? __Set_BufData(pbuf, 34, 1U) : __Set_BufData(pbuf, 3
             -4, 0U);
 115   2              /*设置放电功率*/
 116   2              if (!(pd->Storage.P_Limit > 14U) || !(pd->Storage.P_Limit < 951U))
 117   2              {
 118   3                  pd->Storage.P_Limit = 15U;
 119   3              }
 120   2              __Set_BufData(pbuf, 36, pd->Storage.P_Limit >> 8U), __Set_BufData(pbuf, 37, pd->Storage.P_Limit);
 121   2              /*设置放电截止电压*/
 122   2              if (!(pd->Storage.V_CuttOff > 219U) || !(pd->Storage.V_CuttOff < 601U))
 123   2              {
 124   3                  pd->Storage.V_CuttOff = 220U;
 125   3              }
 126   2              __Set_BufData(pbuf, 32, pd->Storage.V_CuttOff >> 8U), __Set_BufData(pbuf, 35, pd->Storage.V_CuttOf
             -f >> 8U);
 127   2              __Set_BufData(pbuf, 40, pd->Storage.V_CuttOff), __Set_BufData(pbuf, 41, pd->Storage.V_CuttOff);
 128   2              /*设置二次起放电压*/
 129   2              if (!(pd->Storage.V_Reboot > 219U) || !(pd->Storage.V_Reboot < 601U))
 130   2              {
 131   3                  pd->Storage.V_Reboot = 220U;
 132   3              }
 133   2              __Set_BufData(pbuf, 39, pd->Storage.V_Reboot >> 8U), __Set_BufData(pbuf, 42, pd->Storage.V_Reboot)
             -;
 134   2          }
 135   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1387    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     51      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
