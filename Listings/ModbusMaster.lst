C51 COMPILER V9.60.0.0   MODBUSMASTER                                                      08/02/2022 18:06:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MODBUSMASTER
OBJECT MODULE PLACED IN .\Objects\ModbusMaster.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\ModbusMaster.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Inc;.\SmallRT
                    -OS\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\ModbusMaster.lst) OBJECT(.\Objects\ModbusMaster.obj)

line level    source

   1          /*
   2           * ModbusMaster.c
   3           *
   4           *  Created on: 2022年1月4日
   5           *      Author: play
   6           */
   7          #include "ModbusMaster.h"
   8          #include "usart.h"
   9          #include "Dwin.h"
  10          
  11          MODS_T g_tModS;
  12          
  13          static void MODS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen);
  14          
  15          /**
  16           * @brief  有人云自定义46指令
  17           * @param  slaveaddr 从站地址
  18           * @param  regaddr 寄存器开始地址
  19           * @param  reglength 寄存器长度
  20           * @param  dat 数据
  21           * @retval None
  22           */
  23          void MOD_46H(uint8_t slaveaddr, uint16_t regaddr, uint16_t reglength, uint8_t datalength, uint8_t* dat)
  24          {
  25   1          uint8_t i;
  26   1      
  27   1          g_tModS.TxCount = 0;
  28   1          g_tModS.TxBuf[g_tModS.TxCount++] = slaveaddr;
  29   1          g_tModS.TxBuf[g_tModS.TxCount++] = 0x46;
  30   1          g_tModS.TxBuf[g_tModS.TxCount++] = regaddr >> 8;
  31   1          g_tModS.TxBuf[g_tModS.TxCount++] = regaddr;
  32   1          g_tModS.TxBuf[g_tModS.TxCount++] = reglength >> 8;
  33   1          g_tModS.TxBuf[g_tModS.TxCount++] = reglength;
  34   1          g_tModS.TxBuf[g_tModS.TxCount++] = datalength;
  35   1      
  36   1          for(i = 0; i < datalength; i++)
  37   1          {
  38   2              g_tModS.TxBuf[g_tModS.TxCount++] = dat[i];
  39   2          }
  40   1      
  41   1          MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);
  42   1      }
  43          
  44          /**
  45           * @brief  带CRC的发送从站数据
  46           * @param  _pBuf 数据缓冲区指针
  47           * @param  _ucLen 数据长度
  48           * @retval None
  49           */
  50          void MODS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen)
  51          {
  52   1          uint16_t crc;
  53   1          uint8_t buf[MOD_TX_BUF_SIZE];
  54   1      
C51 COMPILER V9.60.0.0   MODBUSMASTER                                                      08/02/2022 18:06:28 PAGE 2   

  55   1          memcpy(buf, _pBuf, _ucLen);
  56   1          crc = Get_Crc16(_pBuf, _ucLen, 0xffff);
  57   1          buf[_ucLen++] = crc;
  58   1          buf[_ucLen++] = crc >> 8;
  59   1          
  60   1          Uartx_SendStr(&Uart2, buf, _ucLen, UART_BYTE_SENDOVERTIME);
  61   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    298    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    262     141
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
