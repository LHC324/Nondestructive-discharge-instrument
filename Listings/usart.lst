C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\usart.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Inc;.\SmallRTOS
                    -\Inc) DEBUG PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "GPIO.h"
   3          
   4          #if (1 == DWIN_USING_RB)
   5          #include "dwin.h"
   6          #endif
   7          
   8          #if (USIING_OTA)
   9          #include "Modbus.h"
  10          #endif
  11          
  12          /*********************************************************
  13          * å‡½æ•°åï¼š
  14          * åŠŸèƒ½ï¼š
  15          * å‚æ•°ï¼š
  16          * ä½œè€…ï¼šLHC
  17          * noteï¼š
  18                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºç°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸å
             -…¶ä»–
  19                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿æ¥çš„æ¨¡å¼
  20          
  21                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ [2021/5/31]
  22          
  23                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  24                  ï¼ˆåŸºäºSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  25          
  26          **********************************************************/
  27          // Uart_HandleTypeDef Uart1; //ä¸²å£1å¥æŸ„
  28          // Uart_HandleTypeDef Uart2; //ä¸²å£2å¥æŸ„
  29          // Uart_HandleTypeDef Uart3; //ä¸²å£3å¥æŸ„
  30          // Uart_HandleTypeDef Uart4; //ä¸²å£4å¥æŸ„
  31          
  32          Uart_HandleTypeDef Uart_Group[4] = {0, 0, 0, 0};
  33          static uint8_t Uart1_Buffer[128], Uart2_Buffer[2048], Uart3_Buffer[364], Uart4_Buffer[128];
  34          
  35          #define S1BUF SBUF
  36          #define Uartx_CallBack(id)                                             \
  37              do                                                                 \
  38              {                                                                  \
  39                  if ((Uart##id).Rx.pbuf &&                                      \
  40                      !__GET_FLAG((Uart##id).Rx.flag, Finish_Flag))              \
  41                  {                                                              \
  42                      __SET_FLAG((Uart##id).Rx.flag, Start_Flag);                \
  43                      (Uart##id).Rx.pbuf[(Uart##id).Rx.rx_count++] = S##id##BUF; \
  44                      (Uart##id).Rx.rx_count %= (Uart##id).Rx.rx_size;           \
  45                      (Uart##id).Rx.over_time = UARTX_OVERTIMES;                 \
  46                  }                                                              \
  47              } while (false)
  48          #if (!DWIN_USING_RB)
              #else
  50          #define _ringbuffer_put(_id, _rb)                             \
  51              do                                                        \
  52              {                                                         \
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 2   

  53                  _rb->buf[_rb->write_index & _rb->size] = S##_id##BUF; \
  54                  if ((_rb->write_index - _rb->read_index) > _rb->size) \
  55                  {                                                     \
  56                      _rb->read_index = _rb->write_index - _rb->size;   \
  57                  }                                                     \
  58                  _rb->write_index++;                                   \
  59              } while (false)
  60          #endif
  61          
  62          #if !defined(USING_SIMULATE)
  63          /*********************************************************
  64           * å‡½æ•°åï¼švoid Uart_1Init(void)
  65           * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
  66           * å‚æ•°ï¼š
  67           * ä½œè€…ï¼š  LHC
  68           * noteï¼š
  69           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨p
  70           **********************************************************/
  71          void Uart1_Init(uint16_t baud) // ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
  72          {
  73   1          Uart1.Instance = UART1;
  74   1          Uart1.Register_SCON = 0x50; // æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
  75   1          Uart1.Uart_Mode = 0x00;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
  76   1          Uart1.Uart_Count = baud;
  77   1          Uart1.RunUart_Enable = true;
  78   1          Uart1.Interrupt_Enable = true;
  79   1          Uart1.Gpio_Switch = false;   // é»˜è®¤åŠŸèƒ½å¼•è„šåˆ‡æ¢
  80   1          Uart1.Register_AUXR = 0x40;  // å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
  81   1          Uart1.Register_AUXR &= 0xFE; // æ³¢ç‰¹ç‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
  82   1      
  83   1          Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½çº§
  84   1          Uart1.Uart_NVIC.Register_IPH = 0xEF;
  85   1      
  86   1          Uart1.Rx.flag = false;
  87   1          Uart1.Rx.pbuf = Uart1_Buffer;
  88   1          Uart1.Rx.rx_size = sizeof(Uart1_Buffer);
  89   1          Uart1.Rx.rx_count = 0;
  90   1          // Uart1.CallBack = Uartx_CallBack;
  91   1      
  92   1          Uart_Base_MspInit(&Uart1);
  93   1      }
  94          
  95          #if (UAING_AUTO_DOWNLOAD)
  96          /**
  97           * @brief    è½¯ä»¶å¤ä½è‡ªåŠ¨ä¸‹è½½åŠŸèƒ½ï¼Œéœ€è¦åœ¨ä¸²å£ä¸­æ–­é‡Œè°ƒç”¨ï¼Œ
  98           *           éœ€è¦åœ¨STC-ISPåŠ©æ‰‹é‡Œè®¾ç½®ä¸‹è½½å£ä»¤ï¼š10ä¸ª0x7Fã€‚
  99           * @details  Software reset automatic download function,
 100           *                       need to be called in serial interrupt,
 101           *                       The download password needs to be
 102           *                       set in the STC-ISP assistant: 10 0x7F.
 103           * @param    None.
 104           * @return   None.
 105           **/
 106          void Auto_RST_download(void)
 107          {
 108   1          static uint8_t semCont = 0;
 109   1          if (SBUF == 0x7F || SBUF == 0x80)
 110   1          {
 111   2              if (++semCont >= 10)
 112   2              {
 113   3                  semCont = 0;
 114   3                  IAP_CONTR = 0x60;
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 3   

 115   3              }
 116   2          }
 117   1          else
 118   1          {
 119   2              semCont = 0;
 120   2          }
 121   1      }
 122          #endif
 123          
 124          /*********************************************************
 125           * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 0
 126           * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
 127           * å‚æ•°ï¼š
 128           * ä½œè€…ï¼š  LHC
 129           * noteï¼šhttps://blog.csdn.net/jasper_lin/article/details/41170533
 130           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 131           **********************************************************/
 132          void UART1_ISRQ_Handler() // ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
 133          {
 134   1          if (TI) // å‘é€ä¸­æ–­æ ‡å¿—
 135   1          {
 136   2              TI = 0;
 137   2              Uart1.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 138   2          }
 139   1      
 140   1          if (RI) // æ¥æ”¶ä¸­æ–­æ ‡å¿—
 141   1          {
 142   2              RI = 0;
 143   2              // Uart1.Rx.rdata = SBUF;
 144   2              // Uart1.CallBack(&Uart1);
 145   2      #if (UAING_AUTO_DOWNLOAD)
 146   2              Auto_RST_download();
 147   2      #else
                      Uartx_CallBack(1);
              #endif
 150   2          }
 151   1      }
 152          #endif
 153          
 154          /*********************************************************
 155           * å‡½æ•°åï¼švoid Uart_2Init(void)
 156           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
 157           * å‚æ•°ï¼š
 158           * ä½œè€…ï¼š  LHC
 159           * noteï¼š
 160           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 161           **********************************************************/
 162          void Uart2_Init(uint16_t baud) // ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 163          {
 164   1          Uart2.Instance = UART2;
 165   1          Uart2.Register_SCON = 0x10; // æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼Œå¼€å¯ä¸²å£2æ¥æ”¶
 166   1          Uart2.Uart_Mode = 0x00;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 167   1          Uart2.Uart_Count = baud;
 168   1          Uart2.RunUart_Enable = true;
 169   1          Uart2.Interrupt_Enable = 0x01;
 170   1          Uart2.Register_AUXR = 0x14;         // å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
 171   1          Uart2.Uart_NVIC.Register_IP = 0x01; // PS2=1,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬1çº§
 172   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 173   1      
 174   1          Uart2.Rx.flag = false;
 175   1          Uart2.Rx.pbuf = Uart2_Buffer;
 176   1          Uart2.Rx.rx_size = sizeof(Uart2_Buffer);
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 4   

 177   1          Uart2.Rx.rx_count = 0;
 178   1          // Uart2.CallBack = Uartx_CallBack;
 179   1      
 180   1          Uart_Base_MspInit(&Uart2);
 181   1      }
 182          
 183          /*********************************************************
 184           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 1
 185           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 186           * å‚æ•°ï¼š
 187           * ä½œè€…ï¼š  LHC
 188           * noteï¼š
 189           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,4Gå£ç”¨
 190           **********************************************************/
 191          void UART2_ISRQ_Handler()
 192          {
 193   1      #if (USIING_OTA)
 194   1          pModbusHandle pd = &Modbus_Object;
 195   1          struct ringbuffer *const rb = pd->Slave.rb;
 196   1      #endif
 197   1          if (S2CON & S2TI) // å‘é€ä¸­æ–­
 198   1          {
 199   2              S2CON &= ~S2TI;
 200   2              Uart2.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 201   2          }
 202   1      
 203   1          if (S2CON & S2RI) // æ¥æ”¶ä¸­æ–­
 204   1          {
 205   2              S2CON &= ~S2RI;
 206   2      #if (USIING_OTA)
 207   2              if (!pd->Ota_Flag)
 208   2              {
 209   3      #endif
 210   3                  Uartx_CallBack(2);
 211   3      #if (USIING_OTA)
 212   3              }
 213   2              else
 214   2              {
 215   3                  if (NULL == pd || NULL == rb || NULL == rb->buf)
 216   3                      return;
 217   3                  _ringbuffer_put(2, rb);
 218   3              }
 219   2      #endif
 220   2          }
 221   1      }
 222          
 223          ///*********************************************************
 224          //* å‡½æ•°åï¼švoid Uart_3Init(void)
 225          //* åŠŸèƒ½ï¼š  ä¸²å£3çš„åˆå§‹åŒ–
 226          //* å‚æ•°ï¼š
 227          //* ä½œè€…ï¼š  LHC
 228          //* noteï¼š
 229          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,æ©å¤–éƒ¨485è½¬å‘
 230          //**********************************************************/
 231          void Uart3_Init(uint16_t baud) // ä¸²å£3é€‰æ‹©å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 232          {
 233   1          Uart3.Instance = UART3;
 234   1          Uart3.Register_SCON = 0x50; // æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 235   1                                      //  Uart3.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼
             -›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 236   1          Uart3.Uart_Mode = 0x0A;     // æ‰“å¼€å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 237   1          Uart3.Uart_Count = baud;
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 5   

 238   1          Uart3.Interrupt_Enable = 0x08;
 239   1      
 240   1          Uart3.Rx.flag = false;
 241   1          Uart3.Rx.pbuf = Uart3_Buffer;
 242   1          Uart3.Rx.rx_size = sizeof(Uart3_Buffer);
 243   1          Uart3.Rx.rx_count = 0;
 244   1          // Uart3.CallBack = Uartx_CallBack;
 245   1      
 246   1          Uart_Base_MspInit(&Uart3);
 247   1      }
 248          
 249          /*********************************************************
 250           * å‡½æ•°åï¼švoid Uart3_ISR() interrupt 17 using 2
 251           * åŠŸèƒ½ï¼š  ä¸²å£3ä¸­æ–­å‡½æ•°
 252           * å‚æ•°ï¼š
 253           * ä½œè€…ï¼š  LHC
 254           * noteï¼š
 255           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,RS485æ¨¡å—
 256           **********************************************************/
 257          void UART3_ISRQ_Handler()
 258          {
 259   1          /*å‘é€ä¸­æ–­å®Œæˆ*/
 260   1          if (S3CON & S3TI)
 261   1          {
 262   2              S3CON &= ~S3TI;
 263   2              Uart3.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 264   2          }
 265   1          /*æ¥æ”¶ä¸­æ–­*/
 266   1          if (S3CON & S3RI)
 267   1          {
 268   2              S3CON &= ~S3RI;
 269   2              Uartx_CallBack(3);
 270   2          }
 271   1      }
 272          
 273          ///*********************************************************
 274          //* å‡½æ•°åï¼švoid Uart_4Init(void)
 275          //* åŠŸèƒ½ï¼š  ä¸²å£4çš„åˆå§‹åŒ–
 276          //* å‚æ•°ï¼š
 277          //* ä½œè€…ï¼š  LHC
 278          //* noteï¼š
 279          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 280          //**********************************************************/
 281          void Uart4_Init(uint16_t baud) // ä¸²å£4é€‰æ‹©å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 282          {
 283   1          Uart4.Instance = UART4;
 284   1          Uart4.Register_SCON = 0x50; // æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 285   1                                      //  Uart4.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 286   1          Uart4.Uart_Mode = 0xA0;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½;å¼€å¯å®šæ—¶å™¨4ï¼Œ1Tæ¨¡å¼
 287   1          Uart4.Uart_Count = baud;
 288   1          Uart4.Interrupt_Enable = 0x10;
 289   1      
 290   1          Uart4.Rx.flag = false;
 291   1          Uart4.Rx.pbuf = Uart4_Buffer;
 292   1          Uart4.Rx.rx_size = sizeof(Uart4_Buffer);
 293   1          Uart4.Rx.rx_count = 0;
 294   1          // Uart4.CallBack = Uartx_CallBack;
 295   1      
 296   1          Uart_Base_MspInit(&Uart4);
 297   1      }
 298          
 299          /*********************************************************
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 6   

 300           * å‡½æ•°åï¼švoid Uart4_Isr() interrupt 18 using 3
 301           * åŠŸèƒ½ï¼š  ä¸²å£4ä¸­æ–­å‡½æ•°
 302           * å‚æ•°ï¼š
 303           * ä½œè€…ï¼š  LHC
 304           * noteï¼š
 305           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 306           **********************************************************/
 307          void UART4_ISRQ_Handler()
 308          {
 309   1      #if (DWIN_USING_RB)
 310   1          struct ringbuffer *const rb = Dwin_Object.Slave.rb;
 311   1      #endif
 312   1          if (S4CON & S4TI)
 313   1          {
 314   2              S4CON &= ~S4TI;
 315   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 316   2              Uart4.Uartx_busy = false;
 317   2          }
 318   1          /*æ¥æ”¶ä¸­æ–­*/
 319   1          if (S4CON & S4RI)
 320   1          {
 321   2              S4CON &= ~S4RI;
 322   2      #if (!DWIN_USING_RB)
                      Uartx_CallBack(4);
              #else
 325   2              // if (Uart4.pbuf && Uart4.rx_count < rx_size)
 326   2              //     Uart4.pbuf[Uart4.rx_count++] = S4BUF;
 327   2              if (NULL == rb || NULL == rb->buf)
 328   2                  return;
 329   2              _ringbuffer_put(4, rb);
 330   2      
 331   2              // rb->buf[rb->write_index & rb->size] = S4BUF;
 332   2              // /*
 333   2              //  * buffer full strategy: new data will overwrite the oldest data in
 334   2              //  * the buffer
 335   2              //  */
 336   2              // if ((rb->write_index - rb->read_index) > rb->size)
 337   2              // {
 338   2              //     rb->read_index = rb->write_index - rb->size;
 339   2              // }
 340   2      
 341   2              // rb->write_index++;
 342   2      #endif
 343   2          }
 344   1      }
 345          
 346          /**********************************å…¬ç”¨å‡½æ•°************************/
 347          
 348          /*********************************************************
 349           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 350           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 351           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 352           * ä½œè€…ï¼š  LHC
 353           * noteï¼š
 354           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 355           **********************************************************/
 356          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 357          {
 358   1          GPIO_InitTypeDef GPIO_InitStruct = {0};
 359   1          switch (uart_baseHandle->Instance)
 360   1          {
 361   2          case UART1:
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 7   

 362   2          {
 363   3              SCON = uart_baseHandle->Register_SCON;
 364   3              TMOD |= uart_baseHandle->Uart_Mode;
 365   3              TL1 = uart_baseHandle->Uart_Count;
 366   3              TH1 = uart_baseHandle->Uart_Count >> 8;
 367   3              TR1 = uart_baseHandle->RunUart_Enable;
 368   3              AUXR |= uart_baseHandle->Register_AUXR;
 369   3              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 370   3              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 371   3      #if USEING_PRINTF // å¦‚æœä½¿ç”¨printf
                      TI = 1;   // æ”¾åˆ°printfé‡å®šå‘
              #else
 374   3              ES = uart_baseHandle->Interrupt_Enable; // ä¸²å£1ä¸­æ–­å…è®¸ä½
 375   3      #endif
 376   3              /*è®¾ç½®P3.0ä¸ºå‡†åŒå‘å£*/
 377   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 378   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 379   3              GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 380   3      
 381   3              /*è®¾ç½®P3.1ä¸ºæ¨æŒ½è¾“å‡º*/
 382   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 383   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 384   3              GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 385   3          }
 386   2          break;
 387   2          case UART2:
 388   2          {
 389   3              S2CON = uart_baseHandle->Register_SCON;
 390   3              TL2 = uart_baseHandle->Uart_Count;
 391   3              TH2 = uart_baseHandle->Uart_Count >> 8;
 392   3              AUXR |= uart_baseHandle->Register_AUXR;
 393   3              IE2 = (uart_baseHandle->Interrupt_Enable & 0x01); // ä¸²å£2ä¸­æ–­å…è®¸ä½
 394   3              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
 395   3              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 396   3              /*è®¾ç½®P1.0ä¸ºå‡†åŒå‘å£*/
 397   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 398   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 399   3              GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 400   3      
 401   3              /*è®¾ç½®P1.1ä¸ºæ¨æŒ½è¾“å‡º*/
 402   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 403   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 404   3              GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 405   3          }
 406   2          break;
 407   2          case UART3:
 408   2          {
 409   3              S3CON = uart_baseHandle->Register_SCON;
 410   3              T4T3M = uart_baseHandle->Uart_Mode;
 411   3              T3L = uart_baseHandle->Uart_Count;
 412   3              T3H = uart_baseHandle->Uart_Count >> 8;
 413   3              IE2 |= (uart_baseHandle->Interrupt_Enable & 0x08); // ä¸²å£3ä¸­æ–­å…è®¸ä½
 414   3      
 415   3              /*è®¾ç½®P0.0ä¸ºå‡†åŒå‘å£*/
 416   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 417   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 418   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 419   3      
 420   3              // GPIO_InitStruct.Mode = GPIO_OUT_OD;
 421   3              // GPIO_InitStruct.Pin = GPIO_Pin_0;
 422   3              // GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 423   3      
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 8   

 424   3              /*è®¾ç½®P0.1ä¸ºæ¨æŒ½è¾“å‡º*/
 425   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 426   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 427   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 428   3          }
 429   2          break;
 430   2          case UART4:
 431   2          {
 432   3              S4CON = uart_baseHandle->Register_SCON;
 433   3              T4T3M |= uart_baseHandle->Uart_Mode; // æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 434   3              T4L = uart_baseHandle->Uart_Count;
 435   3              T4H = uart_baseHandle->Uart_Count >> 8;
 436   3              IE2 |= (uart_baseHandle->Interrupt_Enable & 0x10); // ä¸²å£4ä¸­æ–­å…è®¸ä½
 437   3      
 438   3              /*è®¾ç½®P0.2ä¸ºå‡†åŒå‘å£*/
 439   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 440   3              GPIO_InitStruct.Pin = GPIO_Pin_2;
 441   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 442   3      
 443   3              /*è®¾ç½®P0.3ä¸ºæ¨æŒ½è¾“å‡º*/
 444   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 445   3              GPIO_InitStruct.Pin = GPIO_Pin_3;
 446   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 447   3          }
 448   2          break;
 449   2          default:
 450   2              break;
 451   2          }
 452   1      }
 453          
 454          /*********************************************************
 455           * å‡½æ•°åï¼šUartx_CallBack(Uart_HandleTypeDef *const Uart)
 456           * åŠŸèƒ½ï¼š  ä¸²å£ä¸­æ–­é€šç”¨å›è°ƒå‡½æ•°
 457           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart
 458           * ä½œè€…ï¼š  LHC
 459           * noteï¼š
 460           *
 461           **********************************************************/
 462          // void Uartx_CallBack(Uart_HandleTypeDef *const Uart)
 463          // {
 464          //     if (Uart && Uart->Rx.pbuf &&
 465          //         !__GET_FLAG(Uart->Rx.flag, Finish_Flag))
 466          //     {
 467          //         __SET_FLAG(Uart->Rx.flag, Start_Flag);
 468          //         //        Uart->Rx.pbuf[Uart->Rx.rx_count] = Uart->Rx.rdata;
 469          //         Uart4.Rx.pbuf[Uart->Rx.rx_count] = Uart->Rx.rdata;
 470          //         Uart->Rx.rx_count++;
 471          //         Uart->Rx.rx_count %= Uart->Rx.rx_size;
 472          //         Uart->Rx.over_time = UARTX_OVERTIMES;
 473          //     }
 474          // #if defined(USING_RGB_LED)
 475          //     LED_B ^= true;
 476          // #endif
 477          // }
 478          
 479          /*********************************************************
 480           * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
 481           * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
 482           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
 483           * ä½œè€…ï¼š  LHC
 484           * noteï¼š
 485           *
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 9   

 486           **********************************************************/
 487          void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
 488          {
 489   1      
 490   1          while (Uart->Uartx_busy) // ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
 491   1          {
 492   2              if (!(overtime--))
 493   2                  break;
 494   2          }
 495   1      
 496   1          Uart->Uartx_busy = true; // å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
 497   1      }
 498          
 499          /*********************************************************
 500           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 501           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 502           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
 503           * ä½œè€…ï¼š  LHC
 504           * noteï¼š
 505           *
 506           **********************************************************/
 507          void Uartx_SendStr(Uart_HandleTypeDef *const Uart, uint8_t *p,
 508                             uint8_t length, uint16_t time_out)
 509          {
 510   1          if (!Uart && !p)
 511   1              return;
 512   1          while (length--)
 513   1          {
 514   2              Busy_Await(&(*Uart), time_out); // ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
 515   2              switch (Uart->Instance)
 516   2              {
 517   3      #if !defined(USING_SIMULATE)
 518   3              case UART1:
 519   3                  SBUF = *p++;
 520   3                  break;
 521   3      #endif
 522   3              case UART2:
 523   3                  S2BUF = *p++;
 524   3                  break;
 525   3              case UART3:
 526   3                  S3BUF = *p++;
 527   3                  break;
 528   3              case UART4:
 529   3                  S4BUF = *p++;
 530   3                  break;
 531   3              default:
 532   3                  break;
 533   3              }
 534   2          }
 535   1      }
 536          
 537          // #if (USING_DEBUG)
 538          /*********************************************************
 539           * å‡½æ•°åï¼šchar putchar(char str)
 540           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 541           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 542           * ä½œè€…ï¼š  LHC
 543           * noteï¼š
 544           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 545           **********************************************************/
 546          void Uartx_Printf(Uart_HandleTypeDef *const uart, const char *format, ...)
 547          {
C51 COMPILER V9.60.0.0   USART                                                             01/15/2023 15:54:12 PAGE 10  

 548   1          uint16_t length = 0;
 549   1          char uart_buf[256] = {0};
 550   1          va_list ap;
 551   1      
 552   1          va_start(ap, format);
 553   1          /*ä½¿ç”¨å¯å˜å‚æ•°çš„å­—ç¬¦ä¸²æ‰“å°,ç±»ä¼¼sprintf*/
 554   1          length = vsprintf(uart_buf, format, ap);
 555   1          va_end(ap);
 556   1      
 557   1          Uartx_SendStr(uart, (uint8_t *)&uart_buf[0], length, UART_BYTE_SENDOVERTIME);
 558   1      }
 559          // #endif
 560          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1631    ----
   CONSTANT SIZE    =    258    ----
   XDATA SIZE       =   2749     328
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
