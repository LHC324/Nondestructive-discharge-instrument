C51 COMPILER V9.60.0.0   USART                                                             08/03/2022 21:14:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\usart.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Inc;.\SmallRTOS\Inc)
                    - DEBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "GPIO.h"
   3          
   4          /*********************************************************
   5          * å‡½æ•°åï¼š
   6          * åŠŸèƒ½ï¼š
   7          * å‚æ•°ï¼š
   8          * ä½œè€…ï¼šLHC
   9          * noteï¼š
  10                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºç°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸å
             -…¶ä»–
  11                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿æ¥çš„æ¨¡å¼
  12          
  13                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ [2021/5/31]
  14          
  15                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  16                  ï¼ˆåŸºäºSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  17          
  18          **********************************************************/
  19          // Uart_HandleTypeDef Uart1; //ä¸²å£1å¥æŸ„
  20          // Uart_HandleTypeDef Uart2; //ä¸²å£2å¥æŸ„
  21          // Uart_HandleTypeDef Uart3; //ä¸²å£3å¥æŸ„
  22          // Uart_HandleTypeDef Uart4; //ä¸²å£4å¥æŸ„
  23          
  24          Uart_HandleTypeDef Uart_Group[4] = {0, 0, 0, 0};
  25          static uint8_t Uart1_Buffer[128], Uart2_Buffer[128], Uart3_Buffer[364], Uart4_Buffer[128];
  26          
  27          // static void Uartx_CallBack(Uart_HandleTypeDef *const Uart);
  28          #define S1BUF NULL
  29          #define Uartx_CallBack(id)                                             \
  30              do                                                                 \
  31              {                                                                  \
  32                  if ((Uart##id).Rx.pbuf &&                                      \
  33                      !__GET_FLAG((Uart##id).Rx.flag, Finish_Flag))              \
  34                  {                                                              \
  35                      __SET_FLAG((Uart##id).Rx.flag, Start_Flag);                \
  36                      (Uart##id).Rx.pbuf[(Uart##id).Rx.rx_count++] = S##id##BUF; \
  37                      (Uart##id).Rx.rx_count %= (Uart##id).Rx.rx_size;           \
  38                      (Uart##id).Rx.over_time = UARTX_OVERTIMES;                 \
  39                  }                                                              \
  40              } while (false)
  41          
  42          #if !defined(USING_SIMULATE)
              /*********************************************************
               * å‡½æ•°åï¼švoid Uart_1Init(void)
               * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
               * å‚æ•°ï¼š
               * ä½œè€…ï¼š  LHC
               * noteï¼š
               *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨p
               **********************************************************/
              void Uart1_Init(uint16_t baud) //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
              {
C51 COMPILER V9.60.0.0   USART                                                             08/03/2022 21:14:10 PAGE 2   

                  Uart1.Instance = UART1;
                  Uart1.Register_SCON = 0x50; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
                  Uart1.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
                  Uart1.Uart_Count = baud;
                  Uart1.RunUart_Enable = true;
                  Uart1.Interrupt_Enable = true;
                  Uart1.Gpio_Switch = false;   //é»˜è®¤åŠŸèƒ½å¼•è„šåˆ‡æ¢
                  Uart1.Register_AUXR = 0x40;  //å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
                  Uart1.Register_AUXR &= 0xFE; //æ³¢ç‰¹ç‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
              
                  Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½çº§
                  Uart1.Uart_NVIC.Register_IPH = 0xEF;
              
                  Uart1.Rx.flag = false;
                  Uart1.Rx.pbuf = Uart1_Buffer;
                  Uart1.Rx.rx_size = sizeof(Uart1_Buffer);
                  Uart1.Rx.rx_count = 0;
                  // Uart1.CallBack = Uartx_CallBack;
              
                  Uart_Base_MspInit(&Uart1);
              }
              
              /*********************************************************
               * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 0
               * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
               * å‚æ•°ï¼š
               * ä½œè€…ï¼š  LHC
               * noteï¼šhttps://blog.csdn.net/jasper_lin/article/details/41170533
               *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
               **********************************************************/
              void Uart1_ISR() interrupt 4 using 0 //ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
              {
                  if (TI) //å‘é€ä¸­æ–­æ ‡å¿—
                  {
                      TI = 0;
                      Uart1.Uartx_busy = false; //å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
                  }
              
                  if (RI) //æ¥æ”¶ä¸­æ–­æ ‡å¿—
                  {
                      RI = 0;
                      // Uart1.Rx.rdata = SBUF;
                      // Uart1.CallBack(&Uart1);
                      Uartx_CallBack(1);
                  }
              }
              #endif
 100          
 101          /*********************************************************
 102           * å‡½æ•°åï¼švoid Uart_2Init(void)
 103           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
 104           * å‚æ•°ï¼š
 105           * ä½œè€…ï¼š  LHC
 106           * noteï¼š
 107           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 108           **********************************************************/
 109          void Uart2_Init(uint16_t baud) //ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 110          {
 111   1          Uart2.Instance = UART2;
 112   1          Uart2.Register_SCON = 0x10; //æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼Œå¼€å¯ä¸²å£2æ¥æ”¶
 113   1          Uart2.Uart_Mode = 0x00;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 114   1          Uart2.Uart_Count = baud;
C51 COMPILER V9.60.0.0   USART                                                             08/03/2022 21:14:10 PAGE 3   

 115   1          Uart2.RunUart_Enable = true;
 116   1          Uart2.Interrupt_Enable = 0x01;
 117   1          Uart2.Register_AUXR = 0x14;         //å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
 118   1          Uart2.Uart_NVIC.Register_IP = 0x01; // PS2=1,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬1çº§
 119   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 120   1      
 121   1          Uart2.Rx.flag = false;
 122   1          Uart2.Rx.pbuf = Uart2_Buffer;
 123   1          Uart2.Rx.rx_size = sizeof(Uart2_Buffer);
 124   1          Uart2.Rx.rx_count = 0;
 125   1          // Uart2.CallBack = Uartx_CallBack;
 126   1      
 127   1          Uart_Base_MspInit(&Uart2);
 128   1      }
 129          
 130          /*********************************************************
 131           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 1
 132           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 133           * å‚æ•°ï¼š
 134           * ä½œè€…ï¼š  LHC
 135           * noteï¼š
 136           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,4Gå£ç”¨
 137           **********************************************************/
 138          void Uart2_ISR() interrupt 8 using 1
 139          {
 140   1          if (S2CON & S2TI) //å‘é€ä¸­æ–­
 141   1          {
 142   2              S2CON &= ~S2TI;
 143   2              Uart2.Uartx_busy = false; //å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 144   2          }
 145   1      
 146   1          if (S2CON & S2RI) //æ¥æ”¶ä¸­æ–­
 147   1          {
 148   2              S2CON &= ~S2RI;
 149   2              Uartx_CallBack(2);
 150   2          }
 151   1      }
 152          
 153          ///*********************************************************
 154          //* å‡½æ•°åï¼švoid Uart_3Init(void)
 155          //* åŠŸèƒ½ï¼š  ä¸²å£3çš„åˆå§‹åŒ–
 156          //* å‚æ•°ï¼š
 157          //* ä½œè€…ï¼š  LHC
 158          //* noteï¼š
 159          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,æ©å¤–éƒ¨485è½¬å‘
 160          //**********************************************************/
 161          void Uart3_Init(uint16_t baud) //ä¸²å£3é€‰æ‹©å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 162          {
 163   1          Uart3.Instance = UART3;
 164   1          Uart3.Register_SCON = 0x50; //æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 165   1                                      // Uart3.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›
             -å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 166   1          Uart3.Uart_Mode = 0x0A;     //æ‰“å¼€å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 167   1          Uart3.Uart_Count = baud;
 168   1          Uart3.Interrupt_Enable = 0x08;
 169   1      
 170   1          Uart3.Rx.flag = false;
 171   1          Uart3.Rx.pbuf = Uart3_Buffer;
 172   1          Uart3.Rx.rx_size = sizeof(Uart3_Buffer);
 173   1          Uart3.Rx.rx_count = 0;
 174   1          // Uart3.CallBack = Uartx_CallBack;
 175   1      
C51 COMPILER V9.60.0.0   USART                                                             08/03/2022 21:14:10 PAGE 4   

 176   1          Uart_Base_MspInit(&Uart3);
 177   1      }
 178          
 179          /*********************************************************
 180           * å‡½æ•°åï¼švoid Uart3_ISR() interrupt 17 using 2
 181           * åŠŸèƒ½ï¼š  ä¸²å£3ä¸­æ–­å‡½æ•°
 182           * å‚æ•°ï¼š
 183           * ä½œè€…ï¼š  LHC
 184           * noteï¼š
 185           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,RS485æ¨¡å—
 186           **********************************************************/
 187          void Uart3_ISR() interrupt 17 using 2
 188          {
 189   1          /*å‘é€ä¸­æ–­å®Œæˆ*/
 190   1          if (S3CON & S3TI)
 191   1          {
 192   2              S3CON &= ~S3TI;
 193   2              Uart3.Uartx_busy = false; //å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 194   2          }
 195   1          /*æ¥æ”¶ä¸­æ–­*/
 196   1          if (S3CON & S3RI)
 197   1          {
 198   2              S3CON &= ~S3RI;
 199   2              Uartx_CallBack(3);
 200   2          }
 201   1      }
 202          
 203          ///*********************************************************
 204          //* å‡½æ•°åï¼švoid Uart_4Init(void)
 205          //* åŠŸèƒ½ï¼š  ä¸²å£4çš„åˆå§‹åŒ–
 206          //* å‚æ•°ï¼š
 207          //* ä½œè€…ï¼š  LHC
 208          //* noteï¼š
 209          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 210          //**********************************************************/
 211          void Uart4_Init(uint16_t baud) //ä¸²å£4é€‰æ‹©å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 212          {
 213   1          Uart4.Instance = UART4;
 214   1          Uart4.Register_SCON = 0x50; //æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 215   1                                      // Uart4.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 216   1          Uart4.Uart_Mode = 0xA0;     //å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½;å¼€å¯å®šæ—¶å™¨4ï¼Œ1Tæ¨¡å¼
 217   1          Uart4.Uart_Count = baud;
 218   1          Uart4.Interrupt_Enable = 0x10;
 219   1      
 220   1          Uart4.Rx.flag = false;
 221   1          Uart4.Rx.pbuf = Uart4_Buffer;
 222   1          Uart4.Rx.rx_size = sizeof(Uart4_Buffer);
 223   1          Uart4.Rx.rx_count = 0;
 224   1          // Uart4.CallBack = Uartx_CallBack;
 225   1      
 226   1          Uart_Base_MspInit(&Uart4);
 227   1      }
 228          
 229          /*********************************************************
 230           * å‡½æ•°åï¼švoid Uart4_Isr() interrupt 18 using 3
 231           * åŠŸèƒ½ï¼š  ä¸²å£4ä¸­æ–­å‡½æ•°
 232           * å‚æ•°ï¼š
 233           * ä½œè€…ï¼š  LHC
 234           * noteï¼š
 235           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 236           **********************************************************/
 237          void Uart4_Isr() interrupt 18 using 3
C51 COMPILER V9.60.0.0   USART                                                             08/03/2022 21:14:10 PAGE 5   

 238          { /*å‘é€ä¸­æ–­*/
 239   1          // SEL_CHANNEL temp_channel = CHANNEL_RS485;
 240   1      
 241   1          if (S4CON & S4TI)
 242   1          {
 243   2              S4CON &= ~S4TI;
 244   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 245   2              Uart4.Uartx_busy = false;
 246   2          }
 247   1          /*æ¥æ”¶ä¸­æ–­*/
 248   1          if (S4CON & S4RI)
 249   1          {
 250   2              S4CON &= ~S4RI;
 251   2              Uartx_CallBack(4);
 252   2          }
 253   1      }
 254          
 255          /**********************************å…¬ç”¨å‡½æ•°************************/
 256          
 257          /*********************************************************
 258           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 259           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 260           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 261           * ä½œè€…ï¼š  LHC
 262           * noteï¼š
 263           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 264           **********************************************************/
 265          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 266          {
 267   1          GPIO_InitTypeDef GPIO_InitStruct = {0};
 268   1          switch (uart_baseHandle->Instance)
 269   1          {
 270   2          case UART1:
 271   2          {
 272   3              SCON = uart_baseHandle->Register_SCON;
 273   3              TMOD |= uart_baseHandle->Uart_Mode;
 274   3              TL1 = uart_baseHandle->Uart_Count;
 275   3              TH1 = uart_baseHandle->Uart_Count >> 8;
 276   3              TR1 = uart_baseHandle->RunUart_Enable;
 277   3              AUXR |= uart_baseHandle->Register_AUXR;
 278   3              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 279   3              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 280   3      #if USEING_PRINTF //å¦‚æœä½¿ç”¨printf
                      TI = 1;   //æ”¾åˆ°printfé‡å®šå‘
              #else
 283   3              ES = uart_baseHandle->Interrupt_Enable; //ä¸²å£1ä¸­æ–­å…è®¸ä½
 284   3      #endif
 285   3              /*è®¾ç½®P3.0ä¸ºå‡†åŒå‘å£*/
 286   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 287   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 288   3              GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 289   3      
 290   3              /*è®¾ç½®P3.1ä¸ºæ¨æŒ½è¾“å‡º*/
 291   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 292   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 293   3              GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 294   3          }
 295   2          break;
 296   2          case UART2:
 297   2          {
 298   3              S2CON = uart_baseHandle->Register_SCON;
 299   3              TL2 = uart_baseHandle->Uart_Count;
C51 COMPILER V9.60.0.0   USART                                                             08/03/2022 21:14:10 PAGE 6   

 300   3              TH2 = uart_baseHandle->Uart_Count >> 8;
 301   3              AUXR |= uart_baseHandle->Register_AUXR;
 302   3              IE2 = (uart_baseHandle->Interrupt_Enable & 0x01); //ä¸²å£2ä¸­æ–­å…è®¸ä½
 303   3              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
 304   3              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 305   3              /*è®¾ç½®P1.0ä¸ºå‡†åŒå‘å£*/
 306   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 307   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 308   3              GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 309   3      
 310   3              /*è®¾ç½®P1.1ä¸ºæ¨æŒ½è¾“å‡º*/
 311   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 312   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 313   3              GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 314   3          }
 315   2          break;
 316   2          case UART3:
 317   2          {
 318   3              S3CON = uart_baseHandle->Register_SCON;
 319   3              T4T3M = uart_baseHandle->Uart_Mode;
 320   3              T3L = uart_baseHandle->Uart_Count;
 321   3              T3H = uart_baseHandle->Uart_Count >> 8;
 322   3              IE2 |= (uart_baseHandle->Interrupt_Enable & 0x08); //ä¸²å£3ä¸­æ–­å…è®¸ä½
 323   3      
 324   3              /*è®¾ç½®P0.0ä¸ºå‡†åŒå‘å£*/
 325   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 326   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 327   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 328   3      
 329   3              // GPIO_InitStruct.Mode = GPIO_OUT_OD;
 330   3              // GPIO_InitStruct.Pin = GPIO_Pin_0;
 331   3              // GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 332   3      
 333   3              /*è®¾ç½®P0.1ä¸ºæ¨æŒ½è¾“å‡º*/
 334   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 335   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 336   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 337   3          }
 338   2          break;
 339   2          case UART4:
 340   2          {
 341   3              S4CON = uart_baseHandle->Register_SCON;
 342   3              T4T3M |= uart_baseHandle->Uart_Mode; //æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 343   3              T4L = uart_baseHandle->Uart_Count;
 344   3              T4H = uart_baseHandle->Uart_Count >> 8;
 345   3              IE2 |= (uart_baseHandle->Interrupt_Enable & 0x10); //ä¸²å£4ä¸­æ–­å…è®¸ä½
 346   3      
 347   3              /*è®¾ç½®P0.2ä¸ºå‡†åŒå‘å£*/
 348   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 349   3              GPIO_InitStruct.Pin = GPIO_Pin_2;
 350   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 351   3      
 352   3              /*è®¾ç½®P0.3ä¸ºæ¨æŒ½è¾“å‡º*/
 353   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 354   3              GPIO_InitStruct.Pin = GPIO_Pin_3;
 355   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 356   3          }
 357   2          break;
 358   2          default:
 359   2              break;
 360   2          }
 361   1      }
C51 COMPILER V9.60.0.0   USART                                                             08/03/2022 21:14:10 PAGE 7   

 362          
 363          /*********************************************************
 364           * å‡½æ•°åï¼šUartx_CallBack(Uart_HandleTypeDef *const Uart)
 365           * åŠŸèƒ½ï¼š  ä¸²å£ä¸­æ–­é€šç”¨å›è°ƒå‡½æ•°
 366           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart
 367           * ä½œè€…ï¼š  LHC
 368           * noteï¼š
 369           *
 370           **********************************************************/
 371          // void Uartx_CallBack(Uart_HandleTypeDef *const Uart)
 372          // {
 373          //     if (Uart && Uart->Rx.pbuf &&
 374          //         !__GET_FLAG(Uart->Rx.flag, Finish_Flag))
 375          //     {
 376          //         __SET_FLAG(Uart->Rx.flag, Start_Flag);
 377          //         //        Uart->Rx.pbuf[Uart->Rx.rx_count] = Uart->Rx.rdata;
 378          //         Uart4.Rx.pbuf[Uart->Rx.rx_count] = Uart->Rx.rdata;
 379          //         Uart->Rx.rx_count++;
 380          //         Uart->Rx.rx_count %= Uart->Rx.rx_size;
 381          //         Uart->Rx.over_time = UARTX_OVERTIMES;
 382          //     }
 383          // #if defined(USING_RGB_LED)
 384          //     LED_B ^= true;
 385          // #endif
 386          // }
 387          
 388          /*********************************************************
 389           * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
 390           * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
 391           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
 392           * ä½œè€…ï¼š  LHC
 393           * noteï¼š
 394           *
 395           **********************************************************/
 396          void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
 397          {
 398   1      
 399   1          while (Uart->Uartx_busy) //ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
 400   1          {
 401   2              if (!(overtime--))
 402   2                  break;
 403   2          }
 404   1      
 405   1          Uart->Uartx_busy = true; //å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
 406   1      }
 407          
 408          /*********************************************************
 409           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 410           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 411           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
 412           * ä½œè€…ï¼š  LHC
 413           * noteï¼š
 414           *
 415           **********************************************************/
 416          void Uartx_SendStr(Uart_HandleTypeDef *const Uart, uint8_t *p,
 417                             uint8_t length, uint16_t time_out)
 418          {
 419   1          if (!Uart && !p)
 420   1              return;
 421   1          while (length--)
 422   1          {
 423   2              Busy_Await(&(*Uart), time_out); //ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
C51 COMPILER V9.60.0.0   USART                                                             08/03/2022 21:14:10 PAGE 8   

 424   2              switch (Uart->Instance)
 425   2              {
 426   3              case UART1:
 427   3                  SBUF = *p++;
 428   3                  break;
 429   3              case UART2:
 430   3                  S2BUF = *p++;
 431   3                  break;
 432   3              case UART3:
 433   3                  S3BUF = *p++;
 434   3                  break;
 435   3              case UART4:
 436   3                  S4BUF = *p++;
 437   3                  break;
 438   3              default:
 439   3                  break;
 440   3              }
 441   2          }
 442   1      }
 443          
 444          /*********************************************************
 445           * å‡½æ•°åï¼šchar putchar(char str)
 446           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 447           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 448           * ä½œè€…ï¼š  LHC
 449           * noteï¼š
 450           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 451           **********************************************************/
 452          void Uartx_Printf(Uart_HandleTypeDef *const uart, const char *format, ...)
 453          {
 454   1          uint16_t length = 0;
 455   1          char uart_buf[256] = {0};
 456   1          va_list ap;
 457   1      
 458   1          va_start(ap, format);
 459   1          /*ä½¿ç”¨å¯å˜å‚æ•°çš„å­—ç¬¦ä¸²æ‰“å°,ç±»ä¼¼sprintf*/
 460   1          length = vsprintf(uart_buf, format, ap);
 461   1          va_end(ap);
 462   1      
 463   1          Uartx_SendStr(uart, (uint8_t *)&uart_buf[0], length, UART_BYTE_SENDOVERTIME);
 464   1      }
 465          
 466          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1221    ----
   CONSTANT SIZE    =    258    ----
   XDATA SIZE       =    828     319
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
