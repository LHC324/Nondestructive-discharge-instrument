C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\usart.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Inc;.\SmallRTOS
                    -\Inc) DEBUG PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "GPIO.h"
   3          
   4          #if (1 == DWIN_USING_RB)
   5          #include "dwin.h"
   6          #endif
   7          
   8          /*********************************************************
   9          * å‡½æ•°åï¼š
  10          * åŠŸèƒ½ï¼š
  11          * å‚æ•°ï¼š
  12          * ä½œè€…ï¼šLHC
  13          * noteï¼š
  14                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºç°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸å
             -…¶ä»–
  15                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿æ¥çš„æ¨¡å¼
  16          
  17                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ [2021/5/31]
  18          
  19                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  20                  ï¼ˆåŸºäºSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  21          
  22          **********************************************************/
  23          // Uart_HandleTypeDef Uart1; //ä¸²å£1å¥æŸ„
  24          // Uart_HandleTypeDef Uart2; //ä¸²å£2å¥æŸ„
  25          // Uart_HandleTypeDef Uart3; //ä¸²å£3å¥æŸ„
  26          // Uart_HandleTypeDef Uart4; //ä¸²å£4å¥æŸ„
  27          
  28          Uart_HandleTypeDef Uart_Group[4] = {0, 0, 0, 0};
  29          static uint8_t Uart1_Buffer[128], Uart2_Buffer[128], Uart3_Buffer[364], Uart4_Buffer[128];
  30          
  31          #define S1BUF SBUF
  32          #define Uartx_CallBack(id)                                             \
  33              do                                                                 \
  34              {                                                                  \
  35                  if ((Uart##id).Rx.pbuf &&                                      \
  36                      !__GET_FLAG((Uart##id).Rx.flag, Finish_Flag))              \
  37                  {                                                              \
  38                      __SET_FLAG((Uart##id).Rx.flag, Start_Flag);                \
  39                      (Uart##id).Rx.pbuf[(Uart##id).Rx.rx_count++] = S##id##BUF; \
  40                      (Uart##id).Rx.rx_count %= (Uart##id).Rx.rx_size;           \
  41                      (Uart##id).Rx.over_time = UARTX_OVERTIMES;                 \
  42                  }                                                              \
  43              } while (false)
  44          #if (!DWIN_USING_RB)
              #else
  46          #define _ringbuffer_put(_id, _rb)                             \
  47              do                                                        \
  48              {                                                         \
  49                  _rb->buf[_rb->write_index & _rb->size] = S##_id##BUF; \
  50                  if ((_rb->write_index - _rb->read_index) > _rb->size) \
  51                  {                                                     \
  52                      _rb->read_index = _rb->write_index - _rb->size;   \
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 2   

  53                  }                                                     \
  54                  _rb->write_index++;                                   \
  55              } while (false)
  56          #endif
  57          
  58          #if !defined(USING_SIMULATE)
  59          /*********************************************************
  60           * å‡½æ•°åï¼švoid Uart_1Init(void)
  61           * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
  62           * å‚æ•°ï¼š
  63           * ä½œè€…ï¼š  LHC
  64           * noteï¼š
  65           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨p
  66           **********************************************************/
  67          void Uart1_Init(uint16_t baud) // ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
  68          {
  69   1          Uart1.Instance = UART1;
  70   1          Uart1.Register_SCON = 0x50; // æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
  71   1          Uart1.Uart_Mode = 0x00;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
  72   1          Uart1.Uart_Count = baud;
  73   1          Uart1.RunUart_Enable = true;
  74   1          Uart1.Interrupt_Enable = true;
  75   1          Uart1.Gpio_Switch = false;   // é»˜è®¤åŠŸèƒ½å¼•è„šåˆ‡æ¢
  76   1          Uart1.Register_AUXR = 0x40;  // å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
  77   1          Uart1.Register_AUXR &= 0xFE; // æ³¢ç‰¹ç‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
  78   1      
  79   1          Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½çº§
  80   1          Uart1.Uart_NVIC.Register_IPH = 0xEF;
  81   1      
  82   1          Uart1.Rx.flag = false;
  83   1          Uart1.Rx.pbuf = Uart1_Buffer;
  84   1          Uart1.Rx.rx_size = sizeof(Uart1_Buffer);
  85   1          Uart1.Rx.rx_count = 0;
  86   1          // Uart1.CallBack = Uartx_CallBack;
  87   1      
  88   1          Uart_Base_MspInit(&Uart1);
  89   1      }
  90          
  91          #if (UAING_AUTO_DOWNLOAD)
  92          /**
  93           * @brief    è½¯ä»¶å¤ä½è‡ªåŠ¨ä¸‹è½½åŠŸèƒ½ï¼Œéœ€è¦åœ¨ä¸²å£ä¸­æ–­é‡Œè°ƒç”¨ï¼Œ
  94           *           éœ€è¦åœ¨STC-ISPåŠ©æ‰‹é‡Œè®¾ç½®ä¸‹è½½å£ä»¤ï¼š10ä¸ª0x7Fã€‚
  95           * @details  Software reset automatic download function,
  96           *                       need to be called in serial interrupt,
  97           *                       The download password needs to be
  98           *                       set in the STC-ISP assistant: 10 0x7F.
  99           * @param    None.
 100           * @return   None.
 101           **/
 102          void Auto_RST_download(void)
 103          {
 104   1          static uint8_t semCont = 0;
 105   1          if (SBUF == 0x7F || SBUF == 0x80)
 106   1          {
 107   2              if (++semCont >= 10)
 108   2              {
 109   3                  semCont = 0;
 110   3                  IAP_CONTR = 0x60;
 111   3              }
 112   2          }
 113   1          else
 114   1          {
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 3   

 115   2              semCont = 0;
 116   2          }
 117   1      }
 118          #endif
 119          
 120          /*********************************************************
 121           * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 0
 122           * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
 123           * å‚æ•°ï¼š
 124           * ä½œè€…ï¼š  LHC
 125           * noteï¼šhttps://blog.csdn.net/jasper_lin/article/details/41170533
 126           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 127           **********************************************************/
 128          void UART1_ISRQ_Handler() // ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
 129          {
 130   1          if (TI) // å‘é€ä¸­æ–­æ ‡å¿—
 131   1          {
 132   2              TI = 0;
 133   2              Uart1.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 134   2          }
 135   1      
 136   1          if (RI) // æ¥æ”¶ä¸­æ–­æ ‡å¿—
 137   1          {
 138   2              RI = 0;
 139   2              // Uart1.Rx.rdata = SBUF;
 140   2              // Uart1.CallBack(&Uart1);
 141   2      #if (UAING_AUTO_DOWNLOAD)
 142   2              Auto_RST_download();
 143   2      #else
                      Uartx_CallBack(1);
              #endif
 146   2          }
 147   1      }
 148          #endif
 149          
 150          /*********************************************************
 151           * å‡½æ•°åï¼švoid Uart_2Init(void)
 152           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
 153           * å‚æ•°ï¼š
 154           * ä½œè€…ï¼š  LHC
 155           * noteï¼š
 156           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 157           **********************************************************/
 158          void Uart2_Init(uint16_t baud) // ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 159          {
 160   1          Uart2.Instance = UART2;
 161   1          Uart2.Register_SCON = 0x10; // æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼Œå¼€å¯ä¸²å£2æ¥æ”¶
 162   1          Uart2.Uart_Mode = 0x00;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 163   1          Uart2.Uart_Count = baud;
 164   1          Uart2.RunUart_Enable = true;
 165   1          Uart2.Interrupt_Enable = 0x01;
 166   1          Uart2.Register_AUXR = 0x14;         // å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
 167   1          Uart2.Uart_NVIC.Register_IP = 0x01; // PS2=1,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬1çº§
 168   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 169   1      
 170   1          Uart2.Rx.flag = false;
 171   1          Uart2.Rx.pbuf = Uart2_Buffer;
 172   1          Uart2.Rx.rx_size = sizeof(Uart2_Buffer);
 173   1          Uart2.Rx.rx_count = 0;
 174   1          // Uart2.CallBack = Uartx_CallBack;
 175   1      
 176   1          Uart_Base_MspInit(&Uart2);
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 4   

 177   1      }
 178          
 179          /*********************************************************
 180           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 1
 181           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 182           * å‚æ•°ï¼š
 183           * ä½œè€…ï¼š  LHC
 184           * noteï¼š
 185           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,4Gå£ç”¨
 186           **********************************************************/
 187          void UART2_ISRQ_Handler()
 188          {
 189   1          if (S2CON & S2TI) // å‘é€ä¸­æ–­
 190   1          {
 191   2              S2CON &= ~S2TI;
 192   2              Uart2.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 193   2          }
 194   1      
 195   1          if (S2CON & S2RI) // æ¥æ”¶ä¸­æ–­
 196   1          {
 197   2              S2CON &= ~S2RI;
 198   2              Uartx_CallBack(2);
 199   2          }
 200   1      }
 201          
 202          ///*********************************************************
 203          //* å‡½æ•°åï¼švoid Uart_3Init(void)
 204          //* åŠŸèƒ½ï¼š  ä¸²å£3çš„åˆå§‹åŒ–
 205          //* å‚æ•°ï¼š
 206          //* ä½œè€…ï¼š  LHC
 207          //* noteï¼š
 208          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,æ©å¤–éƒ¨485è½¬å‘
 209          //**********************************************************/
 210          void Uart3_Init(uint16_t baud) // ä¸²å£3é€‰æ‹©å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 211          {
 212   1          Uart3.Instance = UART3;
 213   1          Uart3.Register_SCON = 0x50; // æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 214   1                                      //  Uart3.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼
             -›å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 215   1          Uart3.Uart_Mode = 0x0A;     // æ‰“å¼€å®šæ—¶å™¨3ï¼Œ1Tæ¨¡å¼
 216   1          Uart3.Uart_Count = baud;
 217   1          Uart3.Interrupt_Enable = 0x08;
 218   1      
 219   1          Uart3.Rx.flag = false;
 220   1          Uart3.Rx.pbuf = Uart3_Buffer;
 221   1          Uart3.Rx.rx_size = sizeof(Uart3_Buffer);
 222   1          Uart3.Rx.rx_count = 0;
 223   1          // Uart3.CallBack = Uartx_CallBack;
 224   1      
 225   1          Uart_Base_MspInit(&Uart3);
 226   1      }
 227          
 228          /*********************************************************
 229           * å‡½æ•°åï¼švoid Uart3_ISR() interrupt 17 using 2
 230           * åŠŸèƒ½ï¼š  ä¸²å£3ä¸­æ–­å‡½æ•°
 231           * å‚æ•°ï¼š
 232           * ä½œè€…ï¼š  LHC
 233           * noteï¼š
 234           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,RS485æ¨¡å—
 235           **********************************************************/
 236          void UART3_ISRQ_Handler()
 237          {
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 5   

 238   1          /*å‘é€ä¸­æ–­å®Œæˆ*/
 239   1          if (S3CON & S3TI)
 240   1          {
 241   2              S3CON &= ~S3TI;
 242   2              Uart3.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 243   2          }
 244   1          /*æ¥æ”¶ä¸­æ–­*/
 245   1          if (S3CON & S3RI)
 246   1          {
 247   2              S3CON &= ~S3RI;
 248   2              Uartx_CallBack(3);
 249   2          }
 250   1      }
 251          
 252          ///*********************************************************
 253          //* å‡½æ•°åï¼švoid Uart_4Init(void)
 254          //* åŠŸèƒ½ï¼š  ä¸²å£4çš„åˆå§‹åŒ–
 255          //* å‚æ•°ï¼š
 256          //* ä½œè€…ï¼š  LHC
 257          //* noteï¼š
 258          //*             ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 259          //**********************************************************/
 260          void Uart4_Init(uint16_t baud) // ä¸²å£4é€‰æ‹©å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 261          {
 262   1          Uart4.Instance = UART4;
 263   1          Uart4.Register_SCON = 0x50; // æ¨¡å¼0ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 264   1                                      //  Uart4.Register_SCON = 0xD0; //æ¨¡å¼1ï¼Œ9ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
 265   1          Uart4.Uart_Mode = 0xA0;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½;å¼€å¯å®šæ—¶å™¨4ï¼Œ1Tæ¨¡å¼
 266   1          Uart4.Uart_Count = baud;
 267   1          Uart4.Interrupt_Enable = 0x10;
 268   1      
 269   1          Uart4.Rx.flag = false;
 270   1          Uart4.Rx.pbuf = Uart4_Buffer;
 271   1          Uart4.Rx.rx_size = sizeof(Uart4_Buffer);
 272   1          Uart4.Rx.rx_count = 0;
 273   1          // Uart4.CallBack = Uartx_CallBack;
 274   1      
 275   1          Uart_Base_MspInit(&Uart4);
 276   1      }
 277          
 278          /*********************************************************
 279           * å‡½æ•°åï¼švoid Uart4_Isr() interrupt 18 using 3
 280           * åŠŸèƒ½ï¼š  ä¸²å£4ä¸­æ–­å‡½æ•°
 281           * å‚æ•°ï¼š
 282           * ä½œè€…ï¼š  LHC
 283           * noteï¼š
 284           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨4ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,PLCå£ç”¨
 285           **********************************************************/
 286          void UART4_ISRQ_Handler()
 287          {
 288   1      #if (DWIN_USING_RB)
 289   1          struct ringbuffer *const rb = Dwin_Object.Slave.rb;
 290   1      #endif
 291   1          if (S4CON & S4TI)
 292   1          {
 293   2              S4CON &= ~S4TI;
 294   2              /*å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨*/
 295   2              Uart4.Uartx_busy = false;
 296   2          }
 297   1          /*æ¥æ”¶ä¸­æ–­*/
 298   1          if (S4CON & S4RI)
 299   1          {
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 6   

 300   2              S4CON &= ~S4RI;
 301   2      #if (!DWIN_USING_RB)
                      Uartx_CallBack(4);
              #else
 304   2              // if (Uart4.pbuf && Uart4.rx_count < rx_size)
 305   2              //     Uart4.pbuf[Uart4.rx_count++] = S4BUF;
 306   2              if (NULL == rb || NULL == rb->buf)
 307   2                  return;
 308   2              _ringbuffer_put(4, rb);
 309   2      
 310   2              // rb->buf[rb->write_index & rb->size] = S4BUF;
 311   2              // /*
 312   2              //  * buffer full strategy: new data will overwrite the oldest data in
 313   2              //  * the buffer
 314   2              //  */
 315   2              // if ((rb->write_index - rb->read_index) > rb->size)
 316   2              // {
 317   2              //     rb->read_index = rb->write_index - rb->size;
 318   2              // }
 319   2      
 320   2              // rb->write_index++;
 321   2      #endif
 322   2          }
 323   1      }
 324          
 325          /**********************************å…¬ç”¨å‡½æ•°************************/
 326          
 327          /*********************************************************
 328           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 329           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 330           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 331           * ä½œè€…ï¼š  LHC
 332           * noteï¼š
 333           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 334           **********************************************************/
 335          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 336          {
 337   1          GPIO_InitTypeDef GPIO_InitStruct = {0};
 338   1          switch (uart_baseHandle->Instance)
 339   1          {
 340   2          case UART1:
 341   2          {
 342   3              SCON = uart_baseHandle->Register_SCON;
 343   3              TMOD |= uart_baseHandle->Uart_Mode;
 344   3              TL1 = uart_baseHandle->Uart_Count;
 345   3              TH1 = uart_baseHandle->Uart_Count >> 8;
 346   3              TR1 = uart_baseHandle->RunUart_Enable;
 347   3              AUXR |= uart_baseHandle->Register_AUXR;
 348   3              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 349   3              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 350   3      #if USEING_PRINTF // å¦‚æœä½¿ç”¨printf
                      TI = 1;   // æ”¾åˆ°printfé‡å®šå‘
              #else
 353   3              ES = uart_baseHandle->Interrupt_Enable; // ä¸²å£1ä¸­æ–­å…è®¸ä½
 354   3      #endif
 355   3              /*è®¾ç½®P3.0ä¸ºå‡†åŒå‘å£*/
 356   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 357   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 358   3              GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 359   3      
 360   3              /*è®¾ç½®P3.1ä¸ºæ¨æŒ½è¾“å‡º*/
 361   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 7   

 362   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 363   3              GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 364   3          }
 365   2          break;
 366   2          case UART2:
 367   2          {
 368   3              S2CON = uart_baseHandle->Register_SCON;
 369   3              TL2 = uart_baseHandle->Uart_Count;
 370   3              TH2 = uart_baseHandle->Uart_Count >> 8;
 371   3              AUXR |= uart_baseHandle->Register_AUXR;
 372   3              IE2 = (uart_baseHandle->Interrupt_Enable & 0x01); // ä¸²å£2ä¸­æ–­å…è®¸ä½
 373   3              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
 374   3              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 375   3              /*è®¾ç½®P1.0ä¸ºå‡†åŒå‘å£*/
 376   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 377   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 378   3              GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 379   3      
 380   3              /*è®¾ç½®P1.1ä¸ºæ¨æŒ½è¾“å‡º*/
 381   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 382   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 383   3              GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 384   3          }
 385   2          break;
 386   2          case UART3:
 387   2          {
 388   3              S3CON = uart_baseHandle->Register_SCON;
 389   3              T4T3M = uart_baseHandle->Uart_Mode;
 390   3              T3L = uart_baseHandle->Uart_Count;
 391   3              T3H = uart_baseHandle->Uart_Count >> 8;
 392   3              IE2 |= (uart_baseHandle->Interrupt_Enable & 0x08); // ä¸²å£3ä¸­æ–­å…è®¸ä½
 393   3      
 394   3              /*è®¾ç½®P0.0ä¸ºå‡†åŒå‘å£*/
 395   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 396   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 397   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 398   3      
 399   3              // GPIO_InitStruct.Mode = GPIO_OUT_OD;
 400   3              // GPIO_InitStruct.Pin = GPIO_Pin_0;
 401   3              // GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 402   3      
 403   3              /*è®¾ç½®P0.1ä¸ºæ¨æŒ½è¾“å‡º*/
 404   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 405   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 406   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 407   3          }
 408   2          break;
 409   2          case UART4:
 410   2          {
 411   3              S4CON = uart_baseHandle->Register_SCON;
 412   3              T4T3M |= uart_baseHandle->Uart_Mode; // æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 413   3              T4L = uart_baseHandle->Uart_Count;
 414   3              T4H = uart_baseHandle->Uart_Count >> 8;
 415   3              IE2 |= (uart_baseHandle->Interrupt_Enable & 0x10); // ä¸²å£4ä¸­æ–­å…è®¸ä½
 416   3      
 417   3              /*è®¾ç½®P0.2ä¸ºå‡†åŒå‘å£*/
 418   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 419   3              GPIO_InitStruct.Pin = GPIO_Pin_2;
 420   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 421   3      
 422   3              /*è®¾ç½®P0.3ä¸ºæ¨æŒ½è¾“å‡º*/
 423   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 8   

 424   3              GPIO_InitStruct.Pin = GPIO_Pin_3;
 425   3              GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 426   3          }
 427   2          break;
 428   2          default:
 429   2              break;
 430   2          }
 431   1      }
 432          
 433          /*********************************************************
 434           * å‡½æ•°åï¼šUartx_CallBack(Uart_HandleTypeDef *const Uart)
 435           * åŠŸèƒ½ï¼š  ä¸²å£ä¸­æ–­é€šç”¨å›è°ƒå‡½æ•°
 436           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart
 437           * ä½œè€…ï¼š  LHC
 438           * noteï¼š
 439           *
 440           **********************************************************/
 441          // void Uartx_CallBack(Uart_HandleTypeDef *const Uart)
 442          // {
 443          //     if (Uart && Uart->Rx.pbuf &&
 444          //         !__GET_FLAG(Uart->Rx.flag, Finish_Flag))
 445          //     {
 446          //         __SET_FLAG(Uart->Rx.flag, Start_Flag);
 447          //         //        Uart->Rx.pbuf[Uart->Rx.rx_count] = Uart->Rx.rdata;
 448          //         Uart4.Rx.pbuf[Uart->Rx.rx_count] = Uart->Rx.rdata;
 449          //         Uart->Rx.rx_count++;
 450          //         Uart->Rx.rx_count %= Uart->Rx.rx_size;
 451          //         Uart->Rx.over_time = UARTX_OVERTIMES;
 452          //     }
 453          // #if defined(USING_RGB_LED)
 454          //     LED_B ^= true;
 455          // #endif
 456          // }
 457          
 458          /*********************************************************
 459           * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
 460           * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
 461           * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
 462           * ä½œè€…ï¼š  LHC
 463           * noteï¼š
 464           *
 465           **********************************************************/
 466          void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
 467          {
 468   1      
 469   1          while (Uart->Uartx_busy) // ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
 470   1          {
 471   2              if (!(overtime--))
 472   2                  break;
 473   2          }
 474   1      
 475   1          Uart->Uartx_busy = true; // å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
 476   1      }
 477          
 478          /*********************************************************
 479           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 480           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 481           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
 482           * ä½œè€…ï¼š  LHC
 483           * noteï¼š
 484           *
 485           **********************************************************/
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 9   

 486          void Uartx_SendStr(Uart_HandleTypeDef *const Uart, uint8_t *p,
 487                             uint8_t length, uint16_t time_out)
 488          {
 489   1          if (!Uart && !p)
 490   1              return;
 491   1          while (length--)
 492   1          {
 493   2              Busy_Await(&(*Uart), time_out); // ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
 494   2              switch (Uart->Instance)
 495   2              {
 496   3      #if !defined(USING_SIMULATE)
 497   3              case UART1:
 498   3                  SBUF = *p++;
 499   3                  break;
 500   3      #endif
 501   3              case UART2:
 502   3                  S2BUF = *p++;
 503   3                  break;
 504   3              case UART3:
 505   3                  S3BUF = *p++;
 506   3                  break;
 507   3              case UART4:
 508   3                  S4BUF = *p++;
 509   3                  break;
 510   3              default:
 511   3                  break;
 512   3              }
 513   2          }
 514   1      }
 515          
 516          #if (USING_DEBUG)
 517          /*********************************************************
 518           * å‡½æ•°åï¼šchar putchar(char str)
 519           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 520           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 521           * ä½œè€…ï¼š  LHC
 522           * noteï¼š
 523           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 524           **********************************************************/
 525          void Uartx_Printf(Uart_HandleTypeDef *const uart, const char *format, ...)
 526          {
 527   1          uint16_t length = 0;
 528   1          char uart_buf[256] = {0};
 529   1          va_list ap;
 530   1      
 531   1          va_start(ap, format);
 532   1          /*ä½¿ç”¨å¯å˜å‚æ•°çš„å­—ç¬¦ä¸²æ‰“å°,ç±»ä¼¼sprintf*/
 533   1          length = vsprintf(uart_buf, format, ap);
 534   1          va_end(ap);
 535   1      
 536   1          Uartx_SendStr(uart, (uint8_t *)&uart_buf[0], length, UART_BYTE_SENDOVERTIME);
 537   1      }
 538          #endif
 539          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1493    ----
   CONSTANT SIZE    =    258    ----
   XDATA SIZE       =    829     322
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.60.0.0   USART                                                             01/08/2023 15:24:25 PAGE 10  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
