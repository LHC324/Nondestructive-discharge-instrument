C51 COMPILER V9.60.0.0   TIMER                                                             01/15/2023 15:54:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\Objects\timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\timer.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Inc;.\SmallRTOS
                    -\Inc) DEBUG PRINT(.\Listings\timer.lst) OBJECT(.\Objects\timer.obj)

line level    source

   1          #include "timer.h"
   2          
   3          static void TIM_Base_MspInit(TIM_HandleTypeDef *const tim_baseHandle);
   4          // TIMERS Timer_Group[TIMER_EVENTS];
   5          TIM_HandleTypeDef Timer0;
   6          
   7          soft_timer_t soft_timer_group[] = {
   8                  {false, false, 0},
   9          };
  10          
  11          /*********************************************************
  12           * 函数名： Timer0_Init()
  13           * 功能：   定时器0 的初始化设置
  14           * 参数：   无
  15           * 作者：   LHC
  16           * note：
  17           *                 定时器2、3、4均工作在16bit自动重载模式
  18           **********************************************************/
  19          /*禁止编译器优化该模块*/
  20          #pragma OPTIMIZE(0)
  21          
  22          void Timer0_Init(void)
  23          {
  24   1              Timer0.Instance = TIMER0;
  25   1              /*12T模式*/
  26   1              Timer0.AUXR_Reg.AUXR.AUXR_U8 = 0x7F; // T0X12
  27   1              Timer0.TMOD_Reg.TMOD.TMOD_U8 = 0xF0; // T0_AutoReload_16bit
  28   1              Timer0.Timer_Count = (COUNTMAX - (T12_MODE));
  29   1              /*定时器0优先级为00，最低优先级*/
  30   1              Timer0.Timer_NVIC.IP_Reg.IP.IP_U8 = 0x00;
  31   1              Timer0.Timer_NVIC.IPH_Reg.IPH.IPH_U8 = 0x00;
  32   1              /*开启定时器0中断*/
  33   1              Timer0.IE_Reg.IE.IE_U8 = true;
  34   1              /*开启定时器0*/
  35   1              Timer0.TCON_Reg.TCON.TCON_U8 = true;
  36   1              TIM_Base_MspInit(&Timer0);
  37   1      }
  38          
  39          void TIM_Base_MspInit(TIM_HandleTypeDef *const tim_baseHandle)
  40          { /*首次初始化，把TMOD和AUXR全部置零*/
  41   1              switch (tim_baseHandle->Instance)
  42   1              {
  43   2              case TIMER0:
  44   2              {
  45   3                      AUXR &= tim_baseHandle->AUXR_Reg.AUXR.AUXR_U8;
  46   3                      /*模式0*/
  47   3                      TMOD &= tim_baseHandle->TMOD_Reg.TMOD.TMOD_U8;
  48   3                      /*65536-11.0592M/12/1000 */
  49   3                      TL0 = (uint8_t)(tim_baseHandle->Timer_Count);
  50   3                      TH0 = (uint8_t)((tim_baseHandle->Timer_Count) >> 8);
  51   3                      IP |= tim_baseHandle->Timer_NVIC.IP_Reg.IP.IP_U8;
  52   3                      IPH |= tim_baseHandle->Timer_NVIC.IPH_Reg.IPH.IPH_U8;
  53   3                      /*使能定时器中断*/
  54   3                      ET0 = tim_baseHandle->IE_Reg.IE.IE_U8;
C51 COMPILER V9.60.0.0   TIMER                                                             01/15/2023 15:54:12 PAGE 2   

  55   3                      /*启动定时器0*/
  56   3                      TR0 = tim_baseHandle->TCON_Reg.TCON.TCON_U8;
  57   3                      /*T0溢出中断清零*/
  58   3                      TF0 = 0;
  59   3              }
  60   2              break;
  61   2              default:
  62   2                      break;
  63   2              }
  64   1      }
  65          
  66          #if !defined(USING_RTOS)
  67          /*定时器0的中断服务函数*/
  68          void Timer0_ISR() interrupt 1
  69          {
  70   1              data uint8_t e = 0;
  71   1      
  72   1              for (e = 0; e < g_TimerNumbers; e++)
  73   1              {
  74   2                      if (Timer_Group[e].enable == true) // 使能
  75   2                      {
  76   3                              Timer_Group[e].timercnt++;
  77   3                              if (Timer_Group[e].timercnt == Timer_Group[e].targetcnt)
  78   3                              {
  79   4                                      Timer_Group[e].execute_flag = true;
  80   4                                      Timer_Group[e].timercnt = 0U;
  81   4                              }
  82   3                      }
  83   2              }
  84   1      
  85   1      #define UART_FRAME_SET____________________________________
  86   1              {
  87   2                      /*通用串口数据帧裁定机制*/
  88   2      #include "usart.h"
  89   2                      idata Uart_HandleTypeDef *puart = Uart_Group;
  90   2      
  91   2                      for (; puart && (puart < Uart_Group + UART_GROUP_SIZE()); puart++)
  92   2                      {
  93   3                              // __GET_FLAG(puart->Rx.flag, Start_Flag) ? !puart->Rx.over_time
  94   3                              //      ? __RESET_FLAG(puart->Rx.flag, Start_Flag),
  95   3                              //      __SET_FLAG(puart->Rx.flag, Finish_Flag)
  96   3                              //      : (puart->Rx.over_time--)
  97   3                              //      : false;
  98   3                              if (__GET_FLAG(puart->Rx.flag, Start_Flag))
  99   3                              {
 100   4                                      if (puart->Rx.over_time)
 101   4                                      {
 102   5                                              puart->Rx.over_time--;
 103   5                                      }
 104   4                                      else
 105   4                                      {
 106   5                                              __RESET_FLAG(puart->Rx.flag, Start_Flag),
 107   5                                                      __SET_FLAG(puart->Rx.flag, Finish_Flag);
 108   5                                      }
 109   4                              }
 110   3                      }
 111   2              }
 112   1      #define SOFT_TIMER_SET____________________________________
 113   1              { /*软件定时器*/
 114   2                      soft_timer_t *p = soft_timer_group;
 115   2                      for (; p < soft_timer_group + sizeof(soft_timer_group) / sizeof(soft_timer_group[0]); ++p)
 116   2                      {
C51 COMPILER V9.60.0.0   TIMER                                                             01/15/2023 15:54:12 PAGE 3   

 117   3                              // if (p->set_flag)
 118   3                              if (!(p->count))
 119   3                                      p->flag = true;
 120   3                              else
 121   3                                      p->count--;
 122   3                      }
 123   2              }
 124   1      }
 125          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    878    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =      3    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
